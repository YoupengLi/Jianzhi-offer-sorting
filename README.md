# Jianzhi-offer-sorting
## 第2章 面试需要的基础知识  
面试题3：二维数组中的查找（findIn2DArray）  
面试题4：替换空格（replaceSpace）  
面试题5：从尾到头打印链表（printListFromTailToHead）  
面试题6：重建二叉树（rebuildBinaryTree）  
面试题7：用两个栈实现队列（twoStackForOneQueue）  
扩展：用两个队列实现栈（twoQueueForOneStack）  
面试题8：旋转数组的最小数字（minNumberInRotateArray）  
面试题9：斐波那契数列（fibonacci）  
扩展：青蛙跳台阶（jumpFloor） 矩行覆盖（rectCover）  
面试题10：二进制中1的个数（numberOfOne） 

## 第3章 高质量的代码
面试题11：数值的整数次方（power）  
面试题12：打印1到最大的n位数（printOneToMaxOfNDigits）  
面试题13：在O(1)时间删除链表结点（deleteNode）  
面试题14：调整数组顺序使奇数位于偶数前面（reorderArray）  
面试题15：链表中倒数第k个结点（findKthToTail）  
面试题16：反转链表（reverseList）  
面试题17：合并两个排序的链表（mergeTwoLists）  
面试题18：树的子结构（hasSubtree）  

## 第4章 解决面试题的思路  
面试题19：二叉树的镜像（mirror）  
面试题20：顺时针打印矩阵（printMatrixInCircle）  
面试题21：包含min函数的栈（StackIncludeMinFunction）  
面试题22：栈的压入、弹出序列（isPopOrder）  
面试题23：从上往下打印二叉树（printBinaryTreeFromTopToBottom）  
面试题24：二叉搜索树的后序遍历序列（verifySquenceOfBST）  
面试题25：二叉树中和为某一值的路径（findPath）  
面试题26：复杂链表的复制（cloneRandomList）  
面试题27：二叉搜索树与双向链表（convertFromBSTToList）  
面试题28：字符串的排列（stringPermutation）  

## 第5章 优化时间和空间效率  
面试题29：数组中出现次数超过一半的数字（moreThanHalfNumber）  
面试题30：最小的k个数（getLeastKNumbers）  
面试题31：连续字数组的最大和（findGreatestSumOfSubarray）  
面试题32：从1到n整数中1出现的次数（countDigitOne）  
面试题33：把数组排成最小的数（printMinNumber）  
面试题34：丑数（getUglyNumber）  
面试题35：第一个只出现一次的字符（firstNotRepeatingChar）  
面试题36：数组中的逆序对（getInversePairs）  
面试题37：两个链表的第一个公共结点（findFirstCommonNode）  

## 第6章 面试中的各项能力
面试题38：数字在排序数组中出现的次数（getNumberOfK）  
面试题39.1：二叉树的深度（getTreeDepth）  
面试题39.2：判断二叉树是否是平衡二叉树（isBalancedBinaryTree）  
面试题40：数组中只出现一次的数字（findNumbersAppearOnce）  
面试题41.1：和为s的两个数字（findNumbersWithSum）  
面试题41.2：和为s的连续正数序列（findContinuousSequence）  
面试题42.1：翻转单词顺序（reverseSentence）  
面试题42.2：左旋转字符串（leftRotateString）  
面试题43：n个骰子的点数（printProbability）  
面试题44：扑克牌的顺子（isContinuous）  
面试题45：圆圈中最后剩下的数字（lastRemaining）  
面试题46：求1+2+…+n（sum_1）  
面试题47：不用加减乘除做加法（add_1）  

## 第7章 两个面试案例  
面试题49：把字符串转换成整数（strToInt）  
面试题50.1：二叉搜索树中两个结点的最低公共祖先（lowestCommonAncestor_BT）  
面试题50.2：普通树中两个结点的最低公共祖先（lowestCommonAncestor_NormalTree）  
